{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://psdl-lang.org/schema/v0.3/scenario",
  "$comment": "Schema version 0.3.0 (2025-12-14). Breaking change from v0.2: trends cannot contain comparison operators.",
  "title": "PSDL Scenario Schema v0.3",
  "description": "JSON Schema for Patient Scenario Definition Language (PSDL) v0.3 scenario documents. Scenarios define WHAT to detect (clinical intent) using abstract signal references. Physical data bindings belong in Dataset Spec (see dataset_schema.json). See RFC-0004 and RFC-0005.",
  "x-psdl-schema-version": "0.3.0",
  "x-psdl-last-updated": "2025-12-14",
  "type": "object",
  "required": ["psdl_version", "scenario", "signals", "logic", "audit", "outputs"],
  "additionalProperties": false,

  "properties": {
    "psdl_version": {
      "$ref": "#/$defs/PSDLVersion",
      "description": "PSDL specification version. Determines parser behavior and supported features."
    },
    "scenario": {
      "type": "object",
      "required": ["name", "version"],
      "additionalProperties": false,
      "description": "Scenario identification and versioning",
      "properties": {
        "name": {
          "$ref": "#/$defs/ScenarioName",
          "description": "Unique identifier for this scenario"
        },
        "version": {
          "$ref": "#/$defs/SemanticVersion",
          "description": "Scenario content version (tracks clinical logic changes)"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable display name"
        },
        "description": {
          "type": "string",
          "description": "Human-readable description of what this scenario detects"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Tags for categorization and search",
          "examples": [["aki", "nephrology", "kdigo"]]
        }
      }
    },
    "audit": {
      "$ref": "#/$defs/AuditBlock",
      "description": "Required audit information for regulatory compliance"
    },
    "population": {
      "$ref": "#/$defs/PopulationFilter",
      "description": "Define which patients this scenario applies to"
    },
    "signals": {
      "$ref": "#/$defs/SignalDefinitions",
      "description": "Abstract signal references (semantic names only, NO physical bindings)"
    },
    "trends": {
      "$ref": "#/$defs/TrendDefinitions",
      "description": "Computed numeric trends over signals (NO boolean comparisons)"
    },
    "logic": {
      "$ref": "#/$defs/LogicDefinitions",
      "description": "Boolean predicates combining trends and comparisons"
    },
    "state": {
      "$ref": "#/$defs/StateMachine",
      "description": "Optional state machine for tracking clinical state transitions"
    },
    "outputs": {
      "$ref": "#/$defs/OutputDefinitions",
      "description": "Define what the scenario outputs (decision, features, evidence)"
    },
    "metadata": {
      "$ref": "#/$defs/ScenarioMetadata",
      "description": "Additional metadata for documentation and tooling"
    }
  },

  "$defs": {
    "PSDLVersion": {
      "type": "string",
      "pattern": "^0\\.3(\\.\\d+)?$",
      "description": "PSDL specification version (currently 0.3.x)",
      "examples": ["0.3", "0.3.0", "0.3.1"]
    },

    "ScenarioName": {
      "type": "string",
      "pattern": "^[A-Za-z][A-Za-z0-9_-]*$",
      "minLength": 1,
      "maxLength": 128,
      "description": "Valid scenario identifier (starts with letter, alphanumeric with underscores/hyphens)",
      "examples": ["AKI_Detection", "Sepsis_Early_Warning", "ICU_Deterioration_v1"]
    },

    "SemanticVersion": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+(\\.\\d+)?(-[a-zA-Z0-9]+)?$",
      "description": "Semantic version with optional prerelease suffix",
      "examples": ["1.0.0", "2.1.3", "1.0.0-beta"]
    },

    "Identifier": {
      "type": "string",
      "pattern": "^[A-Za-z][A-Za-z0-9_]*$",
      "minLength": 1,
      "maxLength": 64,
      "description": "Internal identifier for signals, trends, and logic. Mixed case allowed for readability in expressions (e.g., 'Cr', 'MAP'). These are local aliases within the scenario.",
      "$comment": "Design decision: Identifiers are local aliases, so mixed case is allowed for readability in trend/logic expressions"
    },

    "SemanticRef": {
      "type": "string",
      "pattern": "^[a-z][a-z0-9_]*$",
      "minLength": 1,
      "maxLength": 64,
      "description": "Semantic reference name. MUST be lowercase for cross-scenario/cross-dataset standardization. Resolved by Dataset Spec to physical data location.",
      "$comment": "CORE-022: Signal 'ref' values MUST be lowercase alphanumeric with underscores for portability",
      "examples": ["creatinine", "heart_rate", "systolic_bp", "lactate"]
    },

    "PopulationFilter": {
      "type": "object",
      "description": "Criteria defining which patients a scenario applies to. Population filter is evaluated BEFORE any trend/logic evaluation (see POP-003). A patient is included if ALL include criteria are true AND NONE of the exclude criteria are true.",
      "additionalProperties": false,
      "properties": {
        "include": {
          "type": "array",
          "description": "Inclusion criteria - ALL must be true (AND logic). Patient must satisfy every criterion to be included.",
          "items": { "$ref": "#/$defs/PopulationExpression" },
          "examples": [["age >= 18", "unit == 'ICU'", "admission_type == 'emergency'"]]
        },
        "exclude": {
          "type": "array",
          "description": "Exclusion criteria - ANY excludes patient (OR logic). If patient matches any exclusion criterion, they are excluded.",
          "items": { "$ref": "#/$defs/PopulationExpression" },
          "examples": [["status == 'comfort_care_only'", "dnr == true"]]
        }
      },
      "$comment": "POP-001: include uses AND logic; POP-002: exclude uses OR logic; POP-003: evaluated before trend/logic"
    },

    "PopulationExpression": {
      "type": "string",
      "description": "Population filter expression. Uses demographic/admission attributes (not signal data). Syntax: <attribute> <operator> <value>. Attributes are resolved by Dataset Spec to patient-level data.",
      "minLength": 1,
      "examples": [
        "age >= 18",
        "age < 65",
        "unit == 'ICU'",
        "admission_type == 'emergency'",
        "status != 'comfort_care_only'",
        "dnr == false",
        "gender == 'F'"
      ],
      "$comment": "Population expressions operate on patient attributes, not time-series signals. Attributes like 'age', 'unit', 'admission_type' are defined in Dataset Spec."
    },

    "SignalDefinitions": {
      "type": "object",
      "description": "Map of signal names to their abstract definitions. Signals use semantic refs only - physical bindings are in Dataset Spec.",
      "minProperties": 1,
      "additionalProperties": {
        "$ref": "#/$defs/SignalSpec"
      },
      "propertyNames": {
        "$ref": "#/$defs/Identifier"
      }
    },

    "SignalSpec": {
      "oneOf": [
        {
          "$ref": "#/$defs/SemanticRef",
          "description": "Shorthand: semantic ref only (e.g., 'creatinine')"
        },
        {
          "type": "object",
          "required": ["ref"],
          "additionalProperties": false,
          "properties": {
            "ref": {
              "$ref": "#/$defs/SemanticRef",
              "description": "Semantic reference name (resolved by Dataset Spec at runtime)"
            },
            "expected_type": {
              "$ref": "#/$defs/SignalType",
              "default": "numeric",
              "description": "Expected data type (validated against Dataset Spec)"
            },
            "expected_unit": {
              "type": "string",
              "description": "Expected unit of measurement (validated against Dataset Spec in strict mode)",
              "examples": ["mg/dL", "mmol/L", "mmHg", "bpm", "celsius", "%"]
            },
            "description": {
              "type": "string",
              "description": "Human-readable description of this signal"
            }
          }
        }
      ]
    },

    "SignalType": {
      "type": "string",
      "enum": ["numeric", "categorical", "boolean", "datetime"],
      "description": "Expected data type of signal values",
      "default": "numeric"
    },

    "TrendDefinitions": {
      "type": "object",
      "description": "Map of trend names to their definitions. Trends produce NUMERIC values only - no boolean comparisons.",
      "additionalProperties": {
        "$ref": "#/$defs/TrendSpec"
      },
      "propertyNames": {
        "$ref": "#/$defs/Identifier"
      }
    },

    "TrendSpec": {
      "oneOf": [
        {
          "$ref": "#/$defs/TrendExpression",
          "description": "Shorthand: expression string only (must return numeric value)"
        },
        {
          "type": "object",
          "required": ["expr"],
          "additionalProperties": false,
          "properties": {
            "type": {
              "$ref": "#/$defs/TrendType",
              "description": "Explicit return type (recommended for clarity)"
            },
            "unit": {
              "type": "string",
              "description": "Unit of the computed value",
              "examples": ["mg/dL", "mg/dL/h", "ratio"]
            },
            "expr": {
              "$ref": "#/$defs/TrendExpression"
            },
            "description": {
              "type": "string",
              "description": "Human-readable explanation of this trend"
            }
          }
        }
      ]
    },

    "TrendType": {
      "type": "string",
      "enum": ["float", "int", "timestamp"],
      "description": "Return type of trend expression (v0.3: NO boolean type)",
      "default": "float"
    },

    "TrendExpression": {
      "type": "string",
      "description": "Trend expression using PSDL operators. MUST return numeric value - NO comparison operators allowed. See spec/grammar/expression.lark",
      "minLength": 1,
      "not": {
        "pattern": "(>=|<=|>(?!=)|<(?!=)|==|!=)"
      },
      "examples": [
        "delta(Cr, 48h)",
        "slope(Lact, 3h)",
        "ema(MAP, 30m)",
        "last(HR)",
        "count(Cr, 48h)",
        "max(Temp, 24h)",
        "min(SpO2, 1h)",
        "last(Cr) / min(Cr, 7d)",
        "sma(HR, 6h)"
      ],
      "$comment": "CORE-031: Parser MUST reject trend expressions containing comparison operators"
    },

    "LogicDefinitions": {
      "type": "object",
      "description": "Map of logic names to their boolean predicates. Logic combines trends with comparison operators.",
      "minProperties": 1,
      "additionalProperties": {
        "$ref": "#/$defs/LogicSpec"
      },
      "propertyNames": {
        "$ref": "#/$defs/Identifier"
      }
    },

    "LogicSpec": {
      "oneOf": [
        {
          "$ref": "#/$defs/LogicExpression",
          "description": "Shorthand: expression string only"
        },
        {
          "type": "object",
          "required": ["when"],
          "additionalProperties": false,
          "properties": {
            "when": {
              "$ref": "#/$defs/LogicExpression",
              "description": "Boolean condition (v0.3 syntax)"
            },
            "severity": {
              "$ref": "#/$defs/SeverityLevel"
            },
            "description": {
              "type": "string",
              "description": "Clinical interpretation of this state"
            },
            "recommendation": {
              "type": "string",
              "description": "Suggested clinical action when triggered"
            }
          }
        }
      ]
    },

    "LogicExpression": {
      "type": "string",
      "description": "Boolean expression combining trends and comparisons using AND, OR, NOT operators. Disambiguation: A simple identifier (e.g., 'aki_stage1') is parsed as a reference to another logic rule if it exists, otherwise as an undefined reference error. To avoid ambiguity, use explicit comparison operators or boolean operators.",
      "minLength": 1,
      "examples": [
        "cr_delta_48h >= 0.3",
        "cr_ratio >= 1.5",
        "aki_by_delta OR aki_by_ratio",
        "NOT recovering AND deteriorating",
        "(fever OR hypothermia) AND tachycardia",
        "last(Cr) >= 4.0"
      ],
      "$comment": "CORE-044: Logic expressions MAY reference other logic rules by name. Parser resolves identifiers: first check logic rules, then trends, then signals."
    },

    "SeverityLevel": {
      "type": "string",
      "enum": ["low", "medium", "high", "critical"],
      "description": "Clinical severity level for alerting and prioritization"
    },

    "OutputDefinitions": {
      "type": "object",
      "description": "Define what the scenario outputs. Three categories: decision (boolean), features (numeric), evidence (audit).",
      "additionalProperties": false,
      "properties": {
        "decision": {
          "type": "object",
          "description": "Boolean decision outputs",
          "additionalProperties": {
            "$ref": "#/$defs/DecisionOutput"
          }
        },
        "features": {
          "type": "object",
          "description": "Numeric feature outputs (for ML/stats)",
          "additionalProperties": {
            "$ref": "#/$defs/FeatureOutput"
          }
        },
        "evidence": {
          "type": "object",
          "description": "Evidence outputs for audit trail",
          "additionalProperties": {
            "$ref": "#/$defs/EvidenceOutput"
          }
        }
      }
    },

    "DecisionOutput": {
      "type": "object",
      "description": "Boolean decision output",
      "required": ["type", "from"],
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["boolean", "enum"],
          "description": "Output type"
        },
        "values": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Valid values for enum type (required when type='enum')"
        },
        "from": {
          "type": "string",
          "pattern": "^(logic|state)\\.[A-Za-z][A-Za-z0-9_]*$",
          "description": "Source reference (must be 'logic.<name>' or 'state.<property>')",
          "examples": ["logic.aki_stage1", "state.current"]
        },
        "description": {
          "type": "string"
        }
      },
      "$comment": "DecisionOutput always requires a source reference; it cannot have computed expressions"
    },

    "FeatureOutput": {
      "type": "object",
      "description": "Numeric feature output for ML/stats",
      "required": ["type"],
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["float", "int"],
          "description": "Output type"
        },
        "unit": {
          "type": "string",
          "description": "Unit of measurement"
        },
        "from": {
          "type": "string",
          "pattern": "^trends\\.[A-Za-z][A-Za-z0-9_]*$",
          "description": "Source reference (must be 'trends.<name>')",
          "examples": ["trends.cr_delta_48h", "trends.lactate_slope"]
        },
        "expr": {
          "type": "string",
          "description": "Expression to compute the feature (use when 'from' is not sufficient)"
        },
        "description": {
          "type": "string"
        }
      },
      "oneOf": [
        { "required": ["from"] },
        { "required": ["expr"] }
      ],
      "$comment": "FeatureOutput requires either 'from' or 'expr' to define the value source"
    },

    "EvidenceOutput": {
      "type": "object",
      "description": "Evidence output for audit trail",
      "required": ["type"],
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["timestamp", "interval", "string[]", "string"],
          "description": "Output type"
        },
        "expr": {
          "type": "string",
          "description": "Expression to compute the evidence (e.g., 'rules_fired()', 'index_time()')"
        },
        "from": {
          "type": "string",
          "description": "Source reference"
        },
        "description": {
          "type": "string"
        }
      },
      "oneOf": [
        { "required": ["from"] },
        { "required": ["expr"] }
      ],
      "$comment": "EvidenceOutput requires either 'from' or 'expr' to define the value source"
    },

    "ScenarioMetadata": {
      "type": "object",
      "description": "Additional metadata for documentation and tooling",
      "additionalProperties": true,
      "properties": {
        "created": {
          "type": "string",
          "format": "date",
          "description": "Date scenario was created"
        },
        "updated": {
          "type": "string",
          "format": "date",
          "description": "Date scenario was last updated"
        },
        "author": {
          "type": "string",
          "description": "Author or organization"
        },
        "reviewers": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Reviewers who approved this scenario"
        },
        "validation_status": {
          "type": "string",
          "enum": ["draft", "validated", "clinical_review", "production"],
          "description": "Current validation status of the scenario"
        },
        "references": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Clinical references or citations"
        }
      }
    },

    "Window": {
      "type": "string",
      "pattern": "^\\d+[smhdw]$",
      "description": "Time window specification: <integer><unit> where unit is s/m/h/d/w",
      "examples": ["30s", "5m", "6h", "48h", "7d", "2w"]
    },

    "WindowedOperator": {
      "type": "string",
      "enum": ["delta", "slope", "sma", "ema", "min", "max", "count", "first", "std", "stddev", "percentile"],
      "description": "Operators that require a time window parameter"
    },

    "PointwiseOperator": {
      "type": "string",
      "enum": ["last", "exists", "missing"],
      "description": "Operators that do not require a time window"
    },

    "ComparisonOperator": {
      "type": "string",
      "enum": ["==", "!=", "<", "<=", ">", ">="],
      "description": "Comparison operators (v0.3: only allowed in Logic layer)"
    },

    "BooleanOperator": {
      "type": "string",
      "enum": ["AND", "OR", "NOT"],
      "description": "Boolean operators for logic expressions"
    },

    "AuditBlock": {
      "type": "object",
      "description": "Required audit information for regulatory compliance and traceability. Core fields are MUST, extended fields are SHOULD for regulated contexts.",
      "required": ["intent", "rationale", "provenance"],
      "additionalProperties": false,
      "properties": {
        "intent": {
          "type": "string",
          "minLength": 10,
          "description": "MUST: What this scenario is designed to detect",
          "examples": ["Detect AKI Stage 1 using KDIGO criteria", "Early sepsis screening using qSOFA"]
        },
        "rationale": {
          "type": "string",
          "minLength": 10,
          "description": "MUST: Clinical rationale for why this detection matters",
          "examples": ["Early detection enables intervention before irreversible kidney damage"]
        },
        "provenance": {
          "$ref": "#/$defs/ProvenanceSpec",
          "description": "MUST: Source of clinical logic"
        },
        "author": {
          "type": "string",
          "description": "SHOULD: Author or organization that created this scenario"
        },
        "created": {
          "type": "string",
          "format": "date",
          "description": "SHOULD: Date scenario was created"
        },
        "risk_class": {
          "type": "string",
          "description": "SHOULD (regulated): Regulatory risk classification (e.g., 'IIa' for EU MDR, 'Class II' for FDA)"
        },
        "evidence_level": {
          "type": "string",
          "description": "SHOULD: Evidence level using GRADE or similar (e.g., '1A', 'moderate')"
        },
        "approved_by": {
          "type": "string",
          "description": "SHOULD (regulated): Approver for clinical use"
        },
        "approval_id": {
          "type": "string",
          "description": "SHOULD (regulated): Approval tracking identifier"
        }
      }
    },

    "ProvenanceSpec": {
      "oneOf": [
        {
          "type": "string",
          "description": "Simple provenance string (legacy compatibility)",
          "examples": ["KDIGO 2012 Guidelines", "Sepsis-3 Consensus Definition"]
        },
        {
          "type": "object",
          "required": ["type", "reference"],
          "additionalProperties": false,
          "description": "Structured provenance (recommended)",
          "properties": {
            "type": {
              "type": "string",
              "enum": ["guideline", "publication", "sop", "regulatory", "expert"],
              "description": "Type of provenance source"
            },
            "reference": {
              "type": "string",
              "description": "Reference name or title"
            },
            "uri": {
              "type": "string",
              "format": "uri",
              "description": "URL or DOI"
            },
            "version": {
              "type": "string",
              "description": "Version or year of the source"
            }
          }
        }
      ]
    },

    "StateMachine": {
      "type": "object",
      "description": "Simple state machine for tracking clinical state transitions",
      "additionalProperties": false,
      "properties": {
        "initial": {
          "type": "string",
          "description": "Initial state when no transitions have occurred",
          "examples": ["normal", "baseline"]
        },
        "states": {
          "type": "array",
          "items": { "type": "string" },
          "description": "All valid states in the state machine",
          "examples": [["normal", "elevated", "critical"]]
        },
        "transitions": {
          "type": "array",
          "items": { "$ref": "#/$defs/StateTransition" },
          "description": "State transition rules"
        }
      }
    },

    "StateTransition": {
      "type": "object",
      "description": "A state transition rule triggered by logic conditions",
      "required": ["from", "to", "when"],
      "additionalProperties": false,
      "properties": {
        "from": {
          "type": "string",
          "description": "Source state (must be declared in states array)"
        },
        "to": {
          "type": "string",
          "description": "Target state (must be declared in states array)"
        },
        "when": {
          "$ref": "#/$defs/LogicRef",
          "description": "Logic rule reference that triggers this transition"
        }
      },
      "$comment": "STATE-003: Transition 'when' MUST reference a logic rule name (not an inline expression)"
    },

    "LogicRef": {
      "type": "string",
      "pattern": "^[A-Za-z][A-Za-z0-9_]*$",
      "minLength": 1,
      "maxLength": 64,
      "description": "Reference to a logic rule by name. MUST match a key in the logic definitions.",
      "examples": ["aki_stage1", "sepsis_alert", "deteriorating"]
    }
  }
}
